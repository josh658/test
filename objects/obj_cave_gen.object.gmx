<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// creating random cave gen

//setting ds grid height and width
height = room_height div CELL_HEIGHT;
width = room_width div CELL_WIDTH;

//creating grid
grid = ds_grid_create(width, height);

//create a grid for path finding
grid_path = mp_grid_create(0, 0, width, height, CELL_WIDTH, CELL_HEIGHT,);

//randomize it
randomize();

//making the start point random at the bottom of the cave
// this will will start anywhere between one pixel from the edge of the map. as to leave room for the walls
//ranSt = irandom(width-3)+1;

//makignthe cursor at 0, 0
cx = obj_player.x div CELL_WIDTH;
cy = height-2;

//moving the player to the starting tile
obj_player.y = cy*CELL_HEIGHT;

//randomly adding tiles to the room
while( cy &gt; 0){
    grid[# cx, cy] = FLOOR;
    //choosing a direction
    var dir = (irandom(3)*90);
    //moving the cursor
    switch(dir){
        case(0):
            cy -= 1;
            break;
        case(90):
            cx += 1;
            break;
        case(180):
            cy += 1;
            break;
        case(270):
            cx -= 1;
            break;
    }
    //clamping the x and y values to they do not go outside of the of 1 to heght -2
    cx = clamp(cx, 1, width-2);
    cy = clamp(cy, 0, height-2);
}


//creating the cylinder infront of the cave
if(obj_player.has_cylinder = false){
    instance_create( (cx*CELL_WIDTH)+ (CELL_WIDTH div 2), (cy+1)*CELL_HEIGHT+(CELL_HEIGHT div 2), obj_cylinder);
    obj_player.cave_count = 0;
}

//creating another cave 'entrance' that leads to the outside or another cave part...
instance_create(cx*CELL_WIDTH, cy*CELL_HEIGHT, obj_cave_ent);

//making the cave exit either a new room or an exit
if(obj_player.cave_count &lt; 3)
    tile_add(bg_wall, 4*16, 5*16, CELL_WIDTH, CELL_HEIGHT, cx*CELL_WIDTH, cy*CELL_HEIGHT, 100000); 
else
    tile_add(bg_wall, 0*16, 5*16, CELL_WIDTH, CELL_HEIGHT, cx*CELL_WIDTH, cy*CELL_HEIGHT, 100000)
    
//marking the walls
for(yy = 0; yy &lt;= height-1; yy++){
    for(xx = 0; xx &lt;= width-1; xx++){
        if(grid[# xx, yy] == FLOOR){
            if(grid[# xx-1, yy] != FLOOR) grid[# xx-1, yy] = WALL;//left
            if(grid[# xx+1, yy] != FLOOR) grid[# xx+1, yy] = WALL;//right
            if(grid[# xx, yy-1] != FLOOR) grid[# xx, yy-1] = WALL;//up
            if(grid[# xx, yy+1] != FLOOR) grid[# xx, yy+1] = WALL;//down
            if(grid[# xx+1, yy-1] != FLOOR) grid[# xx+1, yy-1] = WALL;//topright
            if(grid[# xx-1, yy-1] != FLOOR) grid[# xx-1, yy-1] = WALL;//top left
            if(grid[# xx-1, yy+1] != FLOOR) grid[# xx-1, yy+1] = WALL;//bottom left
            if(grid[# xx+1, yy+1] != FLOOR) grid[# xx+1, yy+1] = WALL;//bottom right
            var rand = irandom(100);
            if(rand &lt; 25 &amp;&amp; obj_player.has_cylinder){
                instance_create( (xx*CELL_WIDTH)+ (CELL_WIDTH div 2), (yy*CELL_HEIGHT)+ (CELL_HEIGHT div 2), obj_enemy);
            }
        }else{
            mp_grid_add_cell(grid_path, xx, yy);
        }
    }   
}

//making the last tile a floor
grid[# cx, cy] = FLOOR;

//making tilse set widths and hight variables
var tw = 16;
var th = 16;

//autotiling
for(yy = 0; yy &lt;= height-1; yy++){
    for(xx = 0; xx &lt;= width-1; xx++){
    //geting the tiles y
    var ty = yy * CELL_HEIGHT;
    //creating boolean variables to check the surouning tiles
    var left = (grid[# xx-1, yy] != FLOOR);
    var right =(grid[# xx+1, yy] != FLOOR);
    var top = (grid[# xx, yy-1] != FLOOR);
    var bottom = (grid[# xx, yy+1] != FLOOR);
    var topright = (grid[# xx+1, yy-1] != FLOOR);
    var topleft = (grid[# xx-1, yy-1] != FLOOR);
    var bottomleft = (grid[# xx-1, yy+1] != FLOOR);
    var bottomright = (grid[# xx+1, yy+1] != FLOOR);
        if(grid[# xx, yy] == FLOOR){
            tile_add(bg_wall, 0*tw, 9*th, CELL_WIDTH, CELL_HEIGHT, xx*CELL_WIDTH, yy*CELL_HEIGHT, 1000000);
                    
            if(right){
                if(bottom &amp;&amp; top){
                    tile_add(bg_wall, tw*3, th*0, tw, th*3, (xx*CELL_WIDTH)+(CELL_WIDTH), (yy*CELL_HEIGHT)-th*3, 1000000);
                    tile_add(bg_wall, tw*3, th*1, tw, th*2, (xx*CELL_WIDTH)+CELL_WIDTH, yy*CELL_HEIGHT, -ty);
                    tile_add(bg_wall, (tw*15)-9, th*0, tw+9, CELL_HEIGHT, (xx*CELL_WIDTH)+(CELL_WIDTH-21), (yy*CELL_HEIGHT)+(th*2), -1000000);
                }else if(!bottomright){
                    if(!topright){
                        tile_add(bg_wall, tw*4, th*0, tw, th*3, (xx*CELL_WIDTH)+(CELL_WIDTH-10), (yy*CELL_HEIGHT)-th*2, 1000000);
                        tile_add(bg_wall, tw*3, th*1, tw, th*2, (xx*CELL_WIDTH)+CELL_WIDTH, yy*CELL_HEIGHT, -ty);
                        tile_add(bg_wall, tw*3, th*1, tw, th, (xx*CELL_WIDTH)+CELL_WIDTH, yy*CELL_HEIGHT, -ty);
                        tile_add(bg_wall, tw*8, th*4, tw, th*3, (xx*CELL_WIDTH)+CELL_WIDTH, yy*CELL_HEIGHT+th, 1000000);
                    }else if(top){
                        tile_add(bg_wall, tw*3, th*0, tw, th*3, (xx*CELL_WIDTH)+(CELL_WIDTH), (yy*CELL_HEIGHT)-th*3, -1000000);
                        tile_add(bg_wall, tw*3, th*1, tw, th*2, (xx*CELL_WIDTH)+CELL_WIDTH, yy*CELL_HEIGHT, -ty);
                        tile_add(bg_wall, tw*3, th*1, tw, th, (xx*CELL_WIDTH)+CELL_WIDTH, yy*CELL_HEIGHT, -ty);
                        tile_add(bg_wall, tw*8, th*4, tw, th*3, (xx*CELL_WIDTH)+CELL_WIDTH, yy*CELL_HEIGHT+th, 1000000);
                    }else{
                        tile_add(bg_wall, tw*3, th*1, tw, th, (xx*CELL_WIDTH)+CELL_WIDTH, yy*CELL_HEIGHT, -ty);
                        tile_add(bg_wall, tw*8, th*4, tw, th*3, (xx*CELL_WIDTH)+CELL_WIDTH, yy*CELL_HEIGHT+th, 1000000);
                    }
                }else if(bottom){
                    tile_add(bg_wall, (tw*15)-9, th*0, tw+9, CELL_HEIGHT, (xx*CELL_WIDTH)+(CELL_WIDTH-21), (yy*CELL_HEIGHT)+(th*2), -1000000);
                    tile_add(bg_wall, tw*3, th*1, tw, th*2, (xx*CELL_WIDTH)+(CELL_WIDTH), yy * CELL_HEIGHT, -ty);
                }else if(!topright){
                        tile_add(bg_wall, tw*4, th*0, tw, th*3, (xx*CELL_WIDTH)+(CELL_WIDTH-10), (yy*CELL_HEIGHT)-th*2, -ty);
                        tile_add(bg_wall, tw*3, th*1, tw, CELL_HEIGHT, (xx*CELL_WIDTH)+CELL_WIDTH, yy*CELL_HEIGHT, -ty);
                }else if(top){
                    tile_add(bg_wall, tw*3, th*0, tw, th*3, (xx*CELL_WIDTH)+(CELL_WIDTH), (yy*CELL_HEIGHT)-th*3, -ty);
                    tile_add(bg_wall, tw*3, th*1, tw, CELL_HEIGHT, (xx*CELL_WIDTH)+CELL_WIDTH, yy*CELL_HEIGHT, -ty);
                }else
                    tile_add(bg_wall, tw*3, th*1, tw, CELL_HEIGHT, (xx*CELL_WIDTH)+(CELL_WIDTH), yy*CELL_HEIGHT, -ty);
            }        
            if(left){
                if(bottom &amp;&amp; top){
                    tile_add(bg_wall, tw*4, th*0, tw, th*3, (xx*CELL_WIDTH)-(tw), (yy*CELL_HEIGHT)-th*3, -ty);
                    tile_add(bg_wall, tw*4, th*1, tw, th*2, (xx*CELL_WIDTH)-tw, yy*CELL_HEIGHT, -ty);
                    tile_add(bg_wall, tw*12, th*0, tw+9, CELL_HEIGHT, (xx*CELL_WIDTH)-(tw-9), (yy*CELL_HEIGHT)+(th*2), -1000000);
                }else if(!bottomleft){
                    if(!topleft){
                        tile_add(bg_wall, tw*3, th*0, tw, th*3, (xx*CELL_WIDTH)-(tw-9), (yy*CELL_HEIGHT)-th*2, -yy);
                        tile_add(bg_wall, tw*4, th*1, tw, th*2, (xx*CELL_WIDTH)-tw, yy*CELL_HEIGHT, -ty);
                        tile_add(bg_wall, tw*4, th*1, tw, th, (xx*CELL_WIDTH)-tw, yy*CELL_HEIGHT, -ty);
                        tile_add(bg_wall, tw*13, th*4, tw, th*3, (xx*CELL_WIDTH)-tw, yy*CELL_HEIGHT+th, 1000000);
                    }else if(top){
                        tile_add(bg_wall, tw*4, th*0, tw, th*3, (xx*CELL_WIDTH)-(tw), (yy*CELL_HEIGHT)-th*3, 1000000);
                        tile_add(bg_wall, tw*4, th*1, tw, th*2, (xx*CELL_WIDTH)-tw, yy*CELL_HEIGHT, -ty);
                        tile_add(bg_wall, tw*4, th*1, tw, th, (xx*CELL_WIDTH)-tw, yy*CELL_HEIGHT, -ty);
                        tile_add(bg_wall, tw*13, th*4, tw, th*3, (xx*CELL_WIDTH)-tw, yy*CELL_HEIGHT+th, 1000000);
                    }else{
                        tile_add(bg_wall, tw*4, th*1, tw, th, (xx*CELL_WIDTH)-tw, yy*CELL_HEIGHT, -ty);
                        tile_add(bg_wall, tw*13, th*4, tw, th*3, (xx*CELL_WIDTH)-tw, yy*CELL_HEIGHT+th, 100000);
                    }
                }else if(bottom){
                    tile_add(bg_wall, tw*12, th*0, tw+9, CELL_HEIGHT, (xx*CELL_WIDTH)-(tw-9), (yy*CELL_HEIGHT)+(th*2), -ty);
                    tile_add(bg_wall, tw*4, th*1, tw, th*2, (xx*CELL_WIDTH)-(tw), yy * CELL_HEIGHT, -ty);
                }else if(!topleft){
                        tile_add(bg_wall, tw*3, th*0, tw, th*3, (xx*CELL_WIDTH)-(tw-9), (yy*CELL_HEIGHT)-th*2, 1000000);
                        tile_add(bg_wall, tw*4, th*1, tw, CELL_HEIGHT, (xx*CELL_WIDTH)-tw, yy*CELL_HEIGHT, -ty);
                }else if(top){
                    tile_add(bg_wall, tw*4, th*0, tw, th*3, (xx*CELL_WIDTH)-(tw), (yy*CELL_HEIGHT)-th*3, 1000000);
                    tile_add(bg_wall, tw*4, th*1, tw, CELL_HEIGHT, (xx*CELL_WIDTH)-tw, yy*CELL_HEIGHT, -ty);
                }else
                    tile_add(bg_wall, tw*4, th*1, tw, CELL_HEIGHT, (xx*CELL_WIDTH)-tw, yy*CELL_HEIGHT, -ty);
            }
            if(top)
                tile_add(bg_wall, tw*9, th*4, CELL_WIDTH, th*3, (xx*CELL_WIDTH), yy*CELL_HEIGHT-th*3, 10000000);
            if(bottom){
                tile_add(bg_wall, tw*13, th*0, tw*2, CELL_HEIGHT, (xx*CELL_WIDTH), yy*CELL_HEIGHT+th*2, -ty);
                tile_add(bg_wall, tw*13, th*0, tw*2, CELL_HEIGHT, (xx*CELL_WIDTH)+tw*2, yy*CELL_HEIGHT+th*2, -ty);
            }
        }
    }
}

//check if the player is on a floor cell
if(grid[# obj_player.x div CELL_WIDTH, obj_player.y div CELL_HEIGHT] != FLOOR){
    room_restart();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// destroy grids
ds_grid_destroy(grid);
mp_grid_destroy(grid_path);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// reset room
room_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
